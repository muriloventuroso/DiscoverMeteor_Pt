---
title: Allow e Deny
slug: allow-e-deny
date: 0008/01/02
number: 8.5
sidebar: true
contents: Aprenda sobre os callbacks Allow e Deny.|Entenda em que order os callbacks são chamados.
paragraphs: 16
---

O sistema de segurança do Meteor permite que controlemos a modificação do banco de dados sem ter que definir métodos toda vez que quisermos fazer alterações.

Pelo fato de precisarmos fazer tarefas auxiliares como decorar o post com propriedades extras e tomar medidas especiais quando a URL do post já tenha sido registrada, usar um método `post` específico faz muito sentido quando o criamos.

Por outro lado, nós não precisamos realmente criar novos métodos para atualizar e deletes posts. Nós precisamos apenas de verificar se o usuário tem permissão para estas ações, e isso é feito facilmente pelos callbacks `allow` e `deny`.

Usar estes callbacks nos permite ser mais declarativos sobre modificações no banco de dados, e dizer que tipo de atualizações pode ser usadas. O fato de eles se integrarem com o sistema de contas é um bônus.

### Callbacks Múltiplos

Nós podemos definir quantos callbacks `allow` forem necessários. Precisamos apenas de _ao menos um_ deles para retornar `true` para a devida mudança que está ocorrendo. Entao quando `Posts.insert` é chamado no navegador (não importando se foi chamado do nosso aplicativo no lado do cliente ou pelo console), o servidor vai chamar uma verificação `insert` permitida até encontrar uma que retorne `true`. Se ele não encontrar nenhuma, ele não permitirá a inserção, e vai retornar um error `403` no cliente.

Similarmente, podemos definir um ou mais callbacks `deny`. Se _qualquer_ destes callbacks retornarem `true`, a mudança vai ser cancelada e um erro `403` vai ser retornado. A lógica disso é que para um `insert` bem sucedido, um ou mais callback `allow` `insert` assim como _todo_ callback `deny` `insert` vai ser executado. 

<%= diagram "allow_deny", "Note: n/e stands for Not Executed" %>

Em outras palavras, Meteor recorre a lista de callbacks começando pelos `deny`, e em seguida por todos os `allow` até que algum retorne `true`.

Um exemplo prático deste padrão poderia ser, por exemplo, ter dois callbacks `allow()`, um verifica se um post pertence ao usuário atual, e o outro se o usuário atual é um administrador. Se você for um administrador, garante que o usuário será capaz de atualizar qualquer post, então pelo menos um dos callbacks retornará `true`.

### Compensação da Latência

Lembre-se que os métodos que fazem mudanças no banco de dados (como `.update ()`) compensam a latência, como qualquer outro método. Por exemplo, se no console do navegador, você tentar remover um post que não é seu, você verá que, por um momento, o posto desaparece porque a coleção local perdeu o documento, mas depois reaparece quando o servidor diz-nos que, não, o documento não foi removido.

É claro que este comportamento não é um problema quando ativado a partir do console (afinal de contas, se o usuário brincar com os dados pelo console, não é nosso problema o que acontece em seus navegadores). No entanto, você precisa ter certeza de que isso não aconteça a partir da interface do usuário. Por exemplo, você precisa ter o cuidado de garantir que os usuários não vejam botões para excluir os documentos que não estão autorizados a excluir.


Felizmente, não muito frequentemente usaremos código extra que define as permissões, compartilhada entre o cliente eo servidor (por exemplo, você poderia escrever uma função `canDeletePost(user, post)` e colocá-la no diretório `/lib`).

### As permissões no lado do servidor


Lembre-se que o sistema de autorização aplica-se apenas a mudanças na base de dados iniciadas no lado do cliente. No servidor, Meteor assume que todas as operações são permitidas.

Isto significa que, se você escrever um método `deletePost` no lado do servidor, o que pode ser chamado a partir do cliente, todos podem excluir qualquer post. Provavelmente não quer fazer isso, a menos que você verifique as permissões do usuário dentro desse método.

### Use deny como um callback

Finalmente, um truque que se pode fazer com `deny` é usá-lo como um callback "OnX". Por exemplo, poderíamos obter um timestamp `lastModified` com o seguinte código:

~~~js
Posts.deny({
  update: function(userId, doc, fields, modifier) {
    doc.lastModified = +(new Date());
    return false;
  },
  transform: null
});
~~~

Como os callbacks `deny` se executam a cada atualização realizada com êxito, sabemos que será executado e, desta forma, podemos fazer alterações no documento de forma estruturada.

É verdade que esta técnica é um pouco duvidosa, então você pode preferir fazer atualizações usando um método. No entanto, é útil saber, e no futuro, nós esperamos ter disponível alguns callbacks do tipo `beforeUpdate`.
